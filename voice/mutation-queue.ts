/**
 * VOICE MUTATION QUEUE
 * In-memory queue for voice commands that will be applied to repo
 * Gets picked up by auto-commit task running in Codespace
 */

import { promises as fs } from 'fs';
import path from 'path';
import { handleAddSection, handlePublishBlog } from './handlers/layout';
import { handleAddMedia } from './handlers/media';
import { handleChangeStyle } from './handlers/style';

interface QueuedMutation {
  id: string;
  type: 'UPDATE_TEXT' | 'ADD_SECTION' | 'ADD_MEDIA' | 'CHANGE_STYLE' | 'PUBLISH_BLOG';
  timestamp: string;
  status: 'pending' | 'applied' | 'failed';
  payload: Record<string, unknown>;
  result?: {
    success: boolean;
    message: string;
  };
}

// In production, this would be a Redis queue or database
// For now, we log to a JSON file that the auto-commit script can read
const _QUEUE_FILE = path.join(process.cwd(), '.voice-mutations.json');

async function readQueue(): Promise<QueuedMutation[]> {
  try {
    const data = await import('fs').then((fs) => fs.readFileSync(_QUEUE_FILE, 'utf8'));
    const parsed = JSON.parse(data) as unknown;
    return Array.isArray(parsed) ? (parsed as QueuedMutation[]) : [];
  } catch (_error: unknown) {
    // Most likely the file doesn't exist yet; start fresh
    return [];
  }
}

async function writeQueue(queue: QueuedMutation[]): Promise<void> {
  await import('fs').then((fs) =>
    fs.writeFileSync(_QUEUE_FILE, JSON.stringify(queue, null, 2), 'utf8')
  );
}

export async function queueMutation(
  mutation: Omit<QueuedMutation, 'id' | 'timestamp' | 'status'>
): Promise<QueuedMutation> {
  const queued: QueuedMutation = {
    ...mutation,
    id: `voice-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    timestamp: new Date().toISOString(),
    status: 'pending',
  };

  try {
    // Log to console for Vercel logs
    console.log(
      `[VOICE MUTATION QUEUED] ${queued.id} - ${queued.type}`,
      JSON.stringify(queued.payload)
    );

    // Persist to queue file so a worker/auto-commit loop can apply the mutation
    const queue = await readQueue();
    queue.push(queued);
    await writeQueue(queue);

    // Attempt to apply immediately so voice commands visibly change the site
    await processPendingMutations();

    // In production, this would write to database
    // For now, just log and return
    return queued;
  } catch (error: unknown) {
    console.error('', error);
    throw error;
  }
}

/**
 * Get mutation status from queue
 */
export function getMutationStatus(_id: string): QueuedMutation | null {
  const queue = safeReadQueue();
  return queue.find((entry) => entry.id === _id) ?? null;
}

/**
 * List pending mutations
 */
export function getPendingMutations(): QueuedMutation[] {
  const queue = safeReadQueue();
  return queue.filter((entry) => entry.status === 'pending');
}

export async function processPendingMutations(): Promise<QueuedMutation[]> {
  console.log('Processing pending mutations...');
  const queue = await readQueue();
  console.log(
    `Read queue, found ${queue.length} items. Pending: ${queue.filter((m) => m.status === 'pending').length}`
  );
  let updated = false;

  for (const mutation of queue) {
    if (mutation.status !== 'pending') continue;

    console.log(`Processing mutation ${mutation.id} (${mutation.type})...`);
    try {
      await applyMutation(mutation);
      mutation.status = 'applied';
      mutation.result = { success: true, message: 'Mutation applied' };
      updated = true;
      console.log(`Mutation ${mutation.id} applied successfully.`);
    } catch (error: unknown) {
      console.error('', error);
      mutation.status = 'failed';
      mutation.result = {
        success: false,
        message: error instanceof Error ? error.message : String(error),
      };
      updated = true;
    }
  }

  if (updated) {
    console.log('Writing updated queue to disk...');
    await writeQueue(queue);
    console.log('Queue written.');
  }

  return queue;
}

async function applyMutation(mutation: QueuedMutation): Promise<void> {
  console.log('Applying mutation:', mutation.type);
  switch (mutation.type) {
    case 'UPDATE_TEXT': {
      const newText = String(mutation.payload?.newText ?? 'Digital Excellence');
      await updateHomeHeroHeadline(newText);
      return;
    }

    case 'ADD_SECTION': {
      const sectionTitle = String(mutation.payload?.sectionTitle ?? 'Voice-Controlled Section');
      const sectionContent = String(
        mutation.payload?.sectionContent ?? 'Autogenerated by 3KAI voice command.'
      );
      await handleAddSection({
        type: 'ADD_SECTION',
        payload: { page: 'page', component: sectionTitle, content: sectionContent },
      });
      return;
    }

    case 'ADD_MEDIA': {
      const mediaUrl = String(mutation.payload?.mediaUrl ?? mutation.payload?.url ?? '');
      const mediaType = (mutation.payload?.type as 'video' | 'image' | 'audio') ?? 'image';
      const page = String(mutation.payload?.page ?? 'page');
      await handleAddMedia({
        type: 'ADD_MEDIA',
        payload: { page, url: mediaUrl, kind: mediaType },
      });
      return;
    }

    case 'CHANGE_STYLE': {
      const cssVariable = String(
        mutation.payload?.cssVariable ?? mutation.payload?.property ?? '--accent-base'
      );
      const value = String(mutation.payload?.value ?? '#D4AF37');
      console.log(`Calling handleChangeStyle for ${cssVariable} -> ${value}`);
      await handleChangeStyle({
        type: 'CHANGE_STYLE',
        payload: { target: cssVariable.startsWith('--') ? cssVariable : `--${cssVariable}`, value },
      });
      return;
    }

    case 'PUBLISH_BLOG': {
      const title = String(
        mutation.payload?.title ?? mutation.payload?.topic ?? 'Voice Automation Update'
      );
      const body = String(
        mutation.payload?.body ?? 'This post was published via 3KAI voice automation.'
      );
      const slug = mutation.payload?.slug ? String(mutation.payload.slug) : undefined;
      await handlePublishBlog({
        type: 'PUBLISH_BLOG',
        payload: { topic: title, body, slug },
      });
      return;
    }

    default:
      throw new Error(`No apply handler for mutation type ${mutation.type}`);
  }
}

async function updateHomeHeroHeadline(newText: string): Promise<void> {
  const homePath = path.join(process.cwd(), 'app/page.tsx');
  const content = await fs.readFile(homePath, 'utf8');

  // Replace the existing headline text while keeping styling intact
  const replaced = content.replace(
    /(\s<span className="animate-neon-flash[^>]*">)[\s\S]*?(<\/span>)/,
    `$1${newText}$2`
  );

  if (replaced !== content) {
    await fs.writeFile(homePath, replaced, 'utf8');
    return;
  }

  // Fallback: inject a simple hero heading near the top of the file
  const fallbackHeading = `\n{/* Voice-applied headline */}\n<h1 className="text-5xl font-black text-white">${newText}</h1>\n`;
  await fs.writeFile(homePath, fallbackHeading + content, 'utf8');
}

function safeReadQueue(): QueuedMutation[] {
  try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const nodeFs = require('fs');
    if (!nodeFs.existsSync(_QUEUE_FILE)) return [];
    const data = nodeFs.readFileSync(_QUEUE_FILE, 'utf8');
    const parsed = JSON.parse(data);
    return Array.isArray(parsed) ? (parsed as QueuedMutation[]) : [];
  } catch (error: unknown) {
    console.error('', error);
    return [];
  }
}
